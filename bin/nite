#!/usr/bin/nbb

;; Copyright Â© 2022, JUXT LTD.

(ns site
  {:clj-kondo/config '{:lint-as {promesa.core/let clojure.core/let}}}
  (:require [clojure.edn :as edn]
            [clojure.tools.cli :refer [parse-opts summarize]]
            [clojure.pprint :refer [pprint]]
            [clojure.string :as str]

            [nbb.core :refer [slurp]]

            ;; TODO: replace
            ;; [cheshire.core :as json]
            ;; [io.aviso.ansi :as ansi]
            ;; [clojure.java.io :as io]
            ;; [clojure.java.shell :as sh]
            [cljs.pprint :refer [pprint]]

            ["axios$default" :as axios]
            ["zx" :refer [$ chalk]]
            ["console$log" :as log]
            [promesa.core :as p]
            ["fs" :as fs]
            ["os" :as os]
            ["util" :refer [format]]
            ))

(def ^:dynamic *silent* nil)
(def ^:dynamic *debug* nil)

;; (def site-root-dir (io/file (first *command-line-args*)))

;; TODO: to fix
(defn edn-to-json
  [edn]
  (-> (edn/read-string {:readers {'juxt.site.alpha/as-str pr-str}} edn)
      #_(clj->js)))

(def env
  (let [js-p (.-env js/process)]
    (into {} (for [k (js-keys js-p)]
               [k (aget js-p k)]))))

(defn env-get [property]
  (cond
    (string? property) (get env property)
    (keyword? property) (get env (name property))
    :else (do (message! "No property found!"))))

(defn error! [& msg]
  (when-not *silent*
    (apply println (apply chalk/red "fail:") msg)))

(defn error-and-exit! [exit & msg]
  (apply error! msg)
  (js/process.exit exit))

(defn error-and-usage! [msg opts]
  (error! msg)
  (println "Usage:")
  (println (:summary opts))
  (js/process.exit 1))

(defn message! [& msg]
  (when-not *silent*
    (apply println (apply chalk/green "site:") msg)))

(def config-file
  (case (os.type)
    ("Linux" "Mac OS X") (str (os.homedir) "/.config/site/config.edn")
    (error-and-exit! 1 "Unsupported OS")))

(defn file-extension
  [path]
  (subs path (inc (str/last-index-of path "."))))

(def config
  (cond-> {}
    (fs/existsSync config-file)
    (merge
     (edn/read-string
      {:readers {'ig/ref identity
                 'ref identity
                 'profile #(get % :prod)
                 'env #(env-get (str %))
                 'join #(apply str %)}}

      ;; You need to call `str` on result as `readFileSync` returns buffer or what
      (str (fs/readFileSync config-file))))

    js/process.env.SITE_BASE_URI  ;; or (get-env "SITE_BASE_URI")
    (assoc :juxt.site.alpha/base-uri js/process.env.SITE_BASE_URI))) ;; or (get-env "SITE_BASE_URI")


;; TODO: Test if it works
(defn get-password-from-unix-pass [unix-pass-password-prefix username]
  (let [filename (str unix-pass-password-prefix username)
        passfile (str (os.homedir) "/.password-store/" filename ".gpg")]
    (if (fs/existsSync passfile)
      (do
        (message! "Extracting password from" (str filename))
        (let [{:keys [exit out]} ($ #js ["gpg -d " (fs/readFileSync passfile)])]
          (when (zero? exit) (str/trim out))))
      (error-and-exit! 1 (format "Passfile does not exist: %s" filename)))))

(defn get-password [unix-pass-password-prefix username]
  (or
   (get-password-from-unix-pass unix-pass-password-prefix username)
   ;; TODO: Try other strategies, like pinentry
   (error-and-exit! 1 "Failed to get password for" username)))


;; (fs.existsSync (fs.opendirSync (str (os.homedir) "/.local/share/site")))
;; TODO:
(defn local-token-file []
  (let [dir (fs.readFileSync (str (os.homedir) "/.local/share/site"))]
    (when-not (.exists dir)
      (when-not (.mkdirs dir)
        (error-and-exit! 1 (str "Failed to make directory: " dir))))
    (fs.readFileSync (str dir "/access-token.json"))))

#_(def get-site-token
  (let [token (-> os
                  .homedir
                  (str "/.local/share/site/access-token.json")
                  fs/readFileSync
                  js/JSON.parse
                  (js->clj :keywordize-keys true)
                  :access_token)]
    (if token
      token
      (prn "Please get a new access-token to proceed"))))

(defn show-config
  "Show configuration"
  [opts]
  (pprint config))

(defn get-password-prefix []
  (or
   (when-let [dir (js/process.env.SITE_PASS_DIR)]
     (cond-> dir
       (not (.endsWith dir "/")) (str "/")))
   (:juxt.site.alpha.unix-pass/password-prefix config)))

(defn get-token
  "Request a token"
  [opts]
  (let [{:keys [base-uri username password password-prefix curl]
         :or {base-uri (:juxt.site.alpha/base-uri config)
              password-prefix (get-password-prefix)
              username (-> os
                           .userInfo
                           (js->clj :keywordize-keys true)
                           :username)}}
        (:options opts)]

    (when password-prefix
      (message! (format "Unix pass prefix: %s" password-prefix)))

    (when-not base-uri (error-and-exit! 1 "Base-URI not specified"))
    (when-not username (error-and-exit! 1 "Username required"))

    (message! "Get token from" (format "%s/_site/token" base-uri))

    (let [{:keys [status headers body]}
          (curl/post
           (format "%s/_site/token" base-uri)
           {:headers {"content-type" "application/x-www-form-urlencoded"}
            :basic-auth [username (or password
                                      (when password-prefix (get-password password-prefix username))
                                      (error-and-exit! 1 "Failed to get password"))]
            :body "grant_type=client_credentials"
            :throw false
            :debug false})]
      (cond
        (= status 401)
        (do
          (message! "Server response:" status body)
          (message! (format "Are your credentials valid? request-id is %s" (get headers "site-request-id"))))

        (= status 200)
        (let [f (local-token-file)
              data (json/decode body)
              expires (java.util.Date.
                       (+ (.getTime (java.util.Date.))
                          (* (get data "expires_in") 1000)))

              data (-> data
                       (assoc "username" username)
                       (assoc "expires" (.format java.time.format.DateTimeFormatter/ISO_INSTANT (.toInstant expires))))]

          (message! (format "Token expires in %s seconds" (get data "expires_in")))
          (message! (format "Storing token in %s" f))
          (spit f (json/encode data {:pretty true}))
          (when curl
            (message! (format "Storing curl config in %s" curl))
            (spit curl (format "-H \"Authorization: Bearer %s\"\n" (get data "access_token")))))

        :else
        (do
          (println "Server response:" status (str/trim body)))))))

(defn check-token []
  )

(defn clear-token []
  )

(defn list-users []
  )

(defn put-user []
  )

(defn reset-password []
  )

(defn put-role []
  )

(defn list-roles []
  )

(defn assign-role []
  )

(defn put-rule []
  )

(defn put-trigger []
  )

(defn put-graphql []
  )

(defn post-graphql []
  )

(defn put-redirect []
  )

(defn put-api []
  )

(defn put-asset []
  )

(defn put-template []
  )

(defn post-resources []
  )

(defn post []
  )

(defn post-json []
  )

(defn put-json []
  )

(defn put-static-site []
  )

(def global-cli-options
  [["-b" "--base-uri BASE-URI" "The Base-URI of the server you are targetting"]
   ["-s" "--silent" "Silent mode"]
   ["-D" "--debug" "Enable debug mode"]
   ["-v" "--verbose" "Verbose mode"]
   ["-h" "--help" "Show this summary"]])

(def commands
  [["config"
    {:description (:doc (meta #'show-config))
     :cli-options []
     :delegate show-config}]

   ["get-token"
    {:description (:doc (meta #'get-token))
     :cli-options [["-u" "--username USERNAME" "Username"]
                   ["-p" "--password PASSWORD" "Password"]
                   ["-K" "--curl FILE" "Store creds in curl config file"]]
     :delegate get-token}]

   ["check-token"
    {:description (:doc (meta #'check-token))
     :cli-options []
     :delegate check-token}]

   ["clear-token"
    {:description (:doc (meta #'clear-token))
     :cli-options []
     :delegate clear-token}]

   ["list-users"
    {:description (:doc (meta #'list-users))
     :cli-options []
     :delegate list-users}]

   ["put-user"
    {:description (:doc (meta #'put-user))
     :cli-options [["-n" "--name NAME" "The user's name"]
                   ["-u" "--username USERNAME" "The username of the user you are creating/updating"]
                   ["-p" "--password PASSWORD" "A temporary password for the user"]
                   ["-e" "--email EMAIL" "The user's email"]]
     :delegate put-user}]

   ["reset-password"
    {:description (:doc (meta #'reset-password))

     :cli-options [["-u" "--username USERNAME" "The username of the user"]
                   ["-p" "--password PASSWORD" "A temporary password for the user"]]
     :delegate reset-password}]

   ["put-role"
    {:description (:doc (meta #'put-role))
     :cli-options [["-r" "--role ROLE" "The role you are creating/updating"]
                   ["-d" "--description DESCRIPTION" "An optional description"]]
     :delegate put-role}]

   ["list-roles"
    {:description (:doc (meta #'list-roles))
     :cli-options []
     :delegate list-roles}]

   ["assign-role"
    {:description (:doc (meta #'assign-role))
     :cli-options [["-u" "--username USERNAME" "The user receiving the role"]
                   ["-r" "--role ROLE" "The role you are assigning"]
                   ["-j" "--justification JUSTIFICATION" "The business justification"]]
     :delegate assign-role}]

   ["put-rule"
    {:description (:doc (meta #'put-rule))
     :cli-options [["-n" "--name NAME" "Rule name"]
                   ["-r" "--rule FILE" "Rule file"]]
     :delegate put-rule}]

   ["put-trigger"
    {:description (:doc (meta #'put-trigger))
     :cli-options [["-n" "--name NAME" "Trigger name"]
                   ["-t" "--trigger FILE" "Trigger file"]]
     :delegate put-trigger}]

   ["put-graphql"
    {:description (:doc (meta #'put-graphql))
     :cli-options [["-f" "--file FILE" "GraphQL schema file"]
                   ["-p" "--path PATH" "The destination path after the base-uri"]]
     :delegate put-graphql}]

   ["post-graphql"
    {:description (:doc (meta #'post-graphql))
     :cli-options [["-f" "--file FILE" "GraphQL request"]
                   ["-p" "--path PATH" "The destination path after the base-uri"]]
     :delegate post-graphql}]

   ["put-redirect"
    {:description (:doc (meta #'put-redirect))
     :cli-options [["-r" "--resource URL" "Resource"]
                   ["-l" "--location URL" "Location to redirect to"]]
     :delegate put-redirect}]

   ["put-api"
    {:description (:doc (meta #'put-api))
     :cli-options [["-n" "--name NAME" "API name"]
                   ["-f" "--openapi FILE" "OpenAPI description file"]]
     :delegate put-api}]

   ["put-asset"
    {:description (:doc (meta #'put-asset))
     :cli-options [["-f" "--file FILE" "The asset file"]
                   ["-p" "--path PATH" "The destination path after the base-uri"]
                   ["-t" "--type MIME_TYPE" "The content-type"]
                   ["-e" "--encoding ENCODING" "The content-encoding (optional)"]
                   ["-l" "--language LANGUAGE" "The content-language (optional)"]
                   ["-r" "--resource URI" "The resource for which this asset is a variant of"]
                   ["-c" "--classification CLASSIFICATION" "The classification (e.g PUBLIC, RESTRICTED) applied to resource"]]
     :delegate put-asset}]

   ["put-template"
    {:description (:doc (meta #'put-template))
     :cli-options [["-f" "--file FILE" "The template file"]
                   ["-p" "--path PATH" "The destination path after the base-uri"]
                   ["-t" "--type MIME_TYPE" "The content-type"]
                   ["-e" "--encoding ENCODING" "The content-encoding (optional)"]
                   ["-l" "--language LANGUAGE" "The content-language (optional)"]
                   ["-d" "--dialect DIALECT" "The template dialect (e.g. selmer, mustache)"]]
     :delegate put-asset}]

   ["post-resources"
    {:description (:doc (meta #'post-resources))
     :cli-options [["-f" "--file FILE" "Resource file (in EDN format)"]]
     :delegate post-resources}]

   ["post"
    {:description (:doc (meta #'post))
     :cli-options
     [ ;; One of these
      ["-p" "--path PATH" "The destination path after the base-uri"]
      ["-u" "--url URL" "URL to post to"]

      ["-t" "--type MIME_TYPE" "The content-type"] ; If missing, try to deduce
                                                   ; from other the file suffix
      ["-e" "--encoding ENCODING" "The content-encoding (optional)"]
      ["-l" "--language LANGUAGE" "The content-language (optional)"]

      ;; One of these
      ["-d" "--data DATA" "Data to post"]
      ["-f" "--file FILE" "File containing data"]]
     :delegate post}]

   ["post-json"
    {:description (:doc (meta #'post-json))
     :cli-options [["-f" "--file FILE" "File containing data"]
                   ["-u" "--url URL" "URL to POST to"]]
     :delegate post-json}]

   ["put-json"
    {:description (:doc (meta #'put-json))
     :cli-options [["-f" "--file FILE" "File containing data"]
                   ["-u" "--url URL" "URL to POST to"]]
     :delegate put-json}]

   ["put-static-site"
    {:description (:doc (meta #'put-static-site))
     :cli-options [["-d" "--directory DIR" "Directory containing static site files"]
                   ["-p" "--path PATH" "Path the site will be available at. e.g -p mysite will make the site available at BASE_URI/mysite/index.html"]
                   ["-spa" "--spa SPA" "If set the html file will be served at PATH/app/*"]]
     :delegate put-static-site}]])

(let [{:keys [options arguments summary errors]}
      (parse-opts (next *command-line-args*)  global-cli-options :in-order true)
      command (first arguments)
      {:keys [cli-options delegate]} ((into {} commands) (first arguments))

      print-summary
      (fn []
        (do
          (println (chalk/green.bold "site"))
          (println)
          (println "This is a resource management tool for Site.")
          (println)
          (println (chalk/white "Usage"))
          (println)
          (println "site <global-options> <subcommand> <subcommand-options>")
          (println)
          (println (chalk/white "Global options"))
          (println summary)
          (println)
          (println (chalk/white "Environment variables"))
          (println)
          (println "SITE_BASE_URI \tSet the default Base-URI")
          (println "SITE_PASS_DIR \tOverride where Unix pass passwords are located")
          (println)
          (println (chalk/white "Subcommands"))
          (println)
          (doseq [[command {:keys [description cli-options delegate]}] commands]
            (apply
             println
             (remove nil? [command (chalk/yellow "(" description (when-not delegate " - coming soon!") ")")]))
            (when-let [summary (:summary (parse-opts [] cli-options))]
              (when-not (str/blank? (str/trim summary))
                (println summary)))
            (println))))]

  (cond
    (contains? options :help)
    (print-summary)

    errors
    (doseq [err errors]
      (println err))

    (find (into {} commands) command)
    (binding [*silent* (:silent options)
              *debug* (:debug options)]
      (if delegate
        (let [opts (parse-opts (next arguments) (concat global-cli-options
                                                        cli-options))]
          (when-let [err (some->> opts :errors (str/join ", "))]
            (println (chalk/red "Error: " err)))
          (delegate
           (-> opts
               (update :options merge options))))
        (println "No implementation:" command)))

    (first arguments)
    (println "Unknown command:" (first arguments))

    :else
    (print-summary)))

;; Local Variables:
;; mode: clojurescript
;; End:
