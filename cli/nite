#!/usr/bin/nbb

;; Copyright Â© 2022, JUXT LTD.

(ns site
  {:clj-kondo/config '{:lint-as {promesa.core/let clojure.core/let}}}
  (:require [clojure.edn :as edn]
            [clojure.tools.cli :refer [parse-opts summarize]]
            [clojure.string :as str]
            [nbb.core :refer [slurp]]
            [cljs.pprint :refer [pprint]]
            [cljs-bean.core :refer [->js ->clj]]
            [applied-science.js-interop :as j]
            ["axios$default" :as axios]
            ["zx" :refer [$ chalk]]
            [promesa.core :as p]
            ["console$log" :as log]
            ["fs" :as fs]
            ["os" :as os]
            ["util" :refer [format]]
            ["path" :as path]))

(def ^:dynamic *silent* nil)
(def ^:dynamic *debug* nil)

(defn edn-to-json
  [edn]
  (-> (edn/read-string {:readers {'juxt.site.alpha/as-str pr-str}} edn)
      (->js)))

(def env
  (let [js-p (.-env js/process)]
    (into {} (for [k (js-keys js-p)]
               [k (aget js-p k)]))))

(defn message! [& msg]
  (when-not *silent*
    (apply println (chalk/green "site:") msg)))

(defn error! [& msg]
  (when-not *silent*
    (apply println (chalk/red "fail:") msg)))

(defn error-and-exit! [exit & msg]
  (apply error! msg)
  (js/process.exit exit))

(defn error-and-usage! [msg opts]
  (error! msg)
  (println "Usage:")
  (println (:summary opts))
  (js/process.exit 1))

(defn env-get [property]
  (cond
    (string? property) (get env property)
    (keyword? property) (get env (name property))
    :else (do (message! "No property found!"))))

(def config-file
  (case (os.type)
    ("Linux" "Mac OS X") (str (os.homedir) "/.config/site/config.edn")
    (error-and-exit! 1 "Unsupported OS")))

(defn file-extension
  [path]
  (subs path (inc (str/last-index-of path "."))))

(def config
  (cond-> {}
    (fs/existsSync config-file)
    (merge
     (edn/read-string
      {:readers {'ig/ref identity
                 'ref identity
                 'profile #(get % :prod)
                 'env #(env-get (str %))
                 'join #(apply str %)}}

      ;; You need to call `str` on result as `readFileSync` returns buffer or what
      (str (fs/readFileSync config-file))))

    js/process.env.SITE_BASE_URI  ;; or (get-env "SITE_BASE_URI")
    (assoc :juxt.site.alpha/base-uri js/process.env.SITE_BASE_URI))) ;; or (get-env "SITE_BASE_URI")

(defn load-token []
  (let [token (-> os
                  .homedir
                  (str "/.local/share/site/access-token.json")
                  fs/readFileSync
                  js/JSON.parse
                  (js->clj :keywordize-keys true)
                  :access_token)]
    (if token
      token
      (prn "Please get a new access-token to proceed"))))

;; While in REPL, remember to re-eval instance creation
;; every time your token has been refreshed.
(def instance
  (axios/create
   (clj->js {"headers"
             {"authorization" (format "Bearer %s" (load-token))}})))

(defn post
  ([url body]
   (post url body {}))
  ([url body headers]
   ;; response contains following keys:
   ;; (:status :statusText :headers :config :request :data)
   (p/let [resp (.post instance
                       url
                       body
                       (j/update-in! instance
                                     [:defaults :headers]
                                     j/extend!
                                     (clj->js headers)))
           resp (->clj resp)]
     resp)))

(defn put
  ([url body]
   (put url body {}))
  ([url body headers]
   ;; response contains following keys:
   ;; (:status :statusText :headers :config :request :data)
   (p/let [resp (.put instance
                      url
                      body
                      (j/update-in! instance
                                    [:defaults :headers]
                                    j/extend!
                                    (clj->js headers)))
           resp (->clj resp)]
     resp)))

(defn put-graphql
  "Put a GraphQL document"
  [opts]
  (let [access-token (load-token)
        {:keys [base-uri file path]
         :or {base-uri (:juxt.site.alpha/base-uri config)}}
        (:options opts)]

    (when-not base-uri (error-and-exit! 1 "Base-URI not specified"))
    (when-not file (error-and-usage! "GraphQL schema file required" opts))
    (when-not (.isFile (fs/lstatSync file)) (error-and-exit! 1 "GraphQL schema file must be a file"))
    (when-not path (error-and-usage! "Path required" opts))

    (p/let [{:keys [status headers request data] :as resp}
            (put
             (format "%s%s" base-uri path)
             (cond-> (fs/readFileSync file "utf-8")
               base-uri (str/replace "{{base-uri}}" base-uri))
             {"content-type" "application/graphql"})]

      (cond
        (#{201 204} status)
        (message! (str "GraphQL document uploaded: "
                       (chalk/blue file)
                       " -> "
                       (chalk/blue path)))

        :else
        (do
          (error! "Server response:" status (str/trim data))
          (message! "Request id:" (:site-request-id headers)))))))

(defn post-graphql
  "Post a GraphQL schema"
  [opts]
  (let [access-token (load-token)
        {:keys [base-uri file path]
         :or {base-uri (:juxt.site.alpha/base-uri config)}}
        (:options opts)]

    (when-not base-uri (error-and-exit! 1 "Base-URI not specified"))
    (when-not file (error-and-usage! "GraphQL schema file required" opts))
    (when-not (.isFile (fs/lstatSync file)) (error-and-exit! 1 "GraphQL schema file must be a file"))
    (when-not path (error-and-usage! "Path required" opts))

    (p/let [{:keys [status headers request data] :as resp}
            (post
             (format "%s%s" base-uri path)
             (->js {"query" (cond-> (fs/readFileSync file "utf-8")
                              base-uri (str/replace "{{base-uri}}" base-uri))})
             {"content-type" "application/json"
              "accept" "text/plain"})]

      (cond
        (= status 200)
        (do
          (message! (format "GraphQL posted"))
          (message! (str/trim data)))

        :else
        (do
          (error! "No response data with status:" status)
          (message! "Request id:" (:site-request-id headers)))))))

(defn infer-content-type
  [extension]
  (case extension
    ("htm" "html") "text/html;charset=utf-8"
    "js" "text/javascript"
    ("map" "json") "application/json"
    "edn" "application/edn"
    "csv" "text/csv"
    "png" "image/png"
    ("jpg" "jpeg") "image/jpeg"
    "svg" "image/svg+xml"
    "ico" "image/x-icon"
    ("gif" "webp" "bmp") (str "image/" extension)
    "css" "text/css; charset=utf-8"
    "txt" "text/plain"
    ("woff" "woff2" "otf" "ttf") (str "font/" extension)
    ("mp4" "mpeg" "webm") (str "video/" extension)
    ("opus" "wav" "aac") (str "audio/" extension)
    "mp3" "audio/mpeg"
    nil))

(defn content-type [filename]
  (when-let [suffix (file-extension filename)]
    (or
     (infer-content-type suffix)
     (do
       (error! "Failed to determine content-type for"
               filename (format "(suffix=%s)" suffix)
               " Falling back to application/octet-stream")
       "application/octet-stream"))))

(defn post-resources
  "Post one or more resources"
  [opts]
  (let [access-token (load-token)
        {:keys [base-uri file]
         :or {base-uri (:juxt.site.alpha/base-uri config)}}
        (:options opts)]

    (when-not base-uri (error-and-exit! 1 "Base-URI not specified"))
    (when-not (fs/existsSync file) (error-and-exit! 1 (str "File not found: " file)))

    (p/let [{:keys [status headers request data] :as resp}
            (post
             (str base-uri "/_site/resources/")
             (cond-> (fs/readFileSync "resources.edn" "utf-8")
               :always (str/replace "{{base-uri}}" base-uri))
             {"content-type" "application/edn"})]

      (message! (format "Posting resources from %s" file))
      (case status
        (201 204)
        (message! (format "Resource %s: %s"
                          (case status 201 "created" 204 "updated")
                          (:location headers)))

        207
        (let [results (edn/read-string data)
              errors (filter #(contains? % :error) results)]
          (dorun
               (map
                (fn [ix r]
                  (cond
                    (< (:status r) 400)
                    (println (chalk/green (format "%d: %s" ix r)))
                    :else
                    (println (chalk/red (format "%d: %s" ix r)))
                (range) results)))
        (do
          (error! "Server response:" status (str/trim data))
          (message! "Request id:" (:site-request-id headers)))))))))


(defn put-static-site
  "Given a path and a directory containing at least an index.html file, serves the
  files in the directory using the given path as the root"
  [opts]
  (try
    (let [access-token (load-token)
          {:keys [base-uri directory path spa]
           :or {base-uri (:juxt.site.alpha/base-uri config)}} (:options opts)]

      (message! "putting site" base-uri directory path)
      (when-not base-uri (error-and-exit! 1 "Base-URI not specified"))
      (when-not (fs/existsSync (str directory "/index.html"))
        (error-and-exit! 1 (str "No index.html found in directory: " directory)))

      (let [base (path.resolve directory)
            relative-path (fn [file] (str path (-> file path.basename (str/replace-first base ""))))
            put-file
            (fn [file]
              (p/let [destination (str base-uri "/" (relative-path file))
                      _ (message! (str "Putting file " (.resolve path file) " to path " destination))

                      {:keys [status headers request data] :as resp}
                      (put
                       destination
                       (fs/readFileSync file)
                       (merge
                        "content-type" (content-type file)
                        (prn (relative-path file))
                        (when (and (str/includes? (relative-path file) "index.html")
                                   spa)
                          (prn "adding headers")
                          {"site-type" "AppRoutes"
                           "site-pattern" (str base-uri "/" path "/app/.*")})))]

                (case status
                  (201 204)
                  (message! (format "Resource %s: %s"
                                    (case status 201 "created" 204 "updated")
                                    headers))

                  207
                  (let [results (edn/read-string data)
                        errors (filter #(contains? % :error) results)]
                    (if (pos? (count errors))
                      (do
                        (error! "Not all resources were accepted:")
                        (dorun (map (fn [ix r]
                                      (cond
                                        (< (:status r) 400)
                                        (println (chalk/green (format "%d: %s" ix r)))
                                        :else
                                        (println (chalk/red (format "%d: %s" ix r)))))
                                    (range) results)))
                      (message! "Resources all posted OK")))

                  (do
                    (error! "Server response:" status (str/trim data))
                    (message! "Request id:" (:site-request-id headers))))))]
        (some->> directory
                 fs/readdirSync
                 (filter #(.isFile (fs/lstatSync (str directory "/" %))))
                 (mapv put-file))
        (message! "Site successfully deployed. Visit "
                  (str base-uri "/" (-> directory
                                        (str "/index.html")
                                        relative-path)))))
    (catch js/Error e (str "error putting static site " e))))

(def global-cli-options
  [["-b" "--base-uri BASE-URI" "The Base-URI of the server you are targetting"]
   ["-s" "--silent" "Silent mode"]
   ["-D" "--debug" "Enable debug mode"]
   ["-v" "--verbose" "Verbose mode"]
   ["-h" "--help" "Show this summary"]])

(def commands
  [["put-graphql"
    {:description (:doc (meta #'put-graphql))
     :cli-options [["-f" "--file FILE" "GraphQL schema file"]
                   ["-p" "--path PATH" "The destination path after the base-uri"]]
     :delegate put-graphql}]

   ["post-graphql"
    {:description (:doc (meta #'post-graphql))
     :cli-options [["-f" "--file FILE" "GraphQL request"]
                   ["-p" "--path PATH" "The destination path after the base-uri"]]
     :delegate post-graphql}]

   ["post-resources"
    {:description (:doc (meta #'post-resources))
     :cli-options [["-f" "--file FILE" "Resource file (in EDN format)"]]
     :delegate post-resources}]

   ["put-static-site"
    {:description (:doc (meta #'put-static-site))
     :cli-options [["-d" "--directory DIR" "Directory containing static site files"]
                   ["-p" "--path PATH" "Path the site will be available at. e.g -p mysite will make the site available at BASE_URI/mysite/index.html"]
                   ["-spa" "--spa SPA" "If set the html file will be served at PATH/app/*"]]
     :delegate put-static-site}]])

(let [{:keys [options arguments summary errors]}
      (parse-opts *command-line-args*  global-cli-options :in-order true)


      command (first arguments)

      {:keys [cli-options delegate]}
      ((into {} commands) command)

      print-summary
      (fn []
        (do
          (println (chalk/green.bold "site"))
          (println)
          (println "This is a resource management tool for Site.")
          (println)
          (println (chalk/white "Usage"))
          (println)
          (println "site <global-options> <subcommand> <subcommand-options>")
          (println)
          (println (chalk/white "Global options"))
          (println summary)
          (println)
          (println (chalk/white "Environment variables"))
          (println)
          (println "SITE_BASE_URI \tSet the default Base-URI")
          (println "SITE_PASS_DIR \tOverride where Unix pass passwords are located")
          (println)
          (println (chalk/white "Subcommands"))
          (println)
          (doseq [[command {:keys [description cli-options delegate]}] commands]
            (apply
             println
             (remove nil? [command (chalk/yellow "(" description (when-not delegate " - coming soon!") ")")]))
            (when-let [summary (:summary (parse-opts [] cli-options))]
              (when-not (str/blank? (str/trim summary))
                (println summary)))
            (println))))]

  (cond
    (contains? options :help)
    (print-summary)

    errors
    (doseq [err errors]
      (println err))

    (find (into {} commands) command)
    (binding [*silent* (:silent options)
              *debug* (:debug options)]
      (if delegate
        (let [opts (parse-opts (next arguments) (concat global-cli-options
                                                        cli-options))]
          (when-let [err (some->> opts :errors (str/join ", "))]
            (println (chalk/red "Error: " err)))
          (delegate
           (-> opts
               (update :options merge options))))
        (println "No implementation:" command)))

    (first arguments)
    (println "Unknown command:" (first arguments))

    :else
    (print-summary)))

;; ./nite put-graphql --file schema.graphql --path testing-site/graphql -b http://localhost:2021/

;; Local Variables:
;; mode: clojurescript
;; End:
