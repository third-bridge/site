= Actions
:toc: left
:experimental:

Site introduces the concept of *Actions* which are the foundational primitives
on which everything else in Site is built.

== Introduction

Actions authorize all reads and writes to the database. Actions also record all
writes, and some reads from the database.

////
TODO: Use xrefs from these bullet-points to more detailed explanations, such
that these set of items can become a launchpad for diving into the
documentation.
////

* Actions run in transaction functions to ensure atomicity and consistency.

* Actions can provide involve input validation.

* Actions define their access control in rules, which are sufficient powerful to
  model any access control policy (RBAC, ABAC, PBAC, etc.)

* Actions leave an audit trail and may trigger alerts.

* Actions can be grouped into OAuth2 scopes.

* Actions can be exposed to the network, using OpenAPI and/or GraphQL operations.

* Actions can cause side-effects (e.g. lambda functions).

* Actions decouple network APIs from lower-level effects. For example, an API
  implementation can use a 'send-email', without having to know the
  implementation details of sending emails.

////
(old text)

A Site instance is a collection of documents, stored in XTDB.

Like XTDB, Site is schemaless and requires that you define your own
documents. However, by included document attributes known to Site (usually in
the `juxt.site.alpha` namespace) Site is able to interpret the documents as web
or API resources, and serve them over HTTP.

We need to set up sufficient resources in the REPL so that we no longer need to
access Site via the REPL.

Secure remote access to Site resources requires an *access token*.

In this section we use the REPL to build up the minimal resources required to
acquire an access token which can let us continue setting up the server
remotely, without requiring further REPL access.

An access token is granted for a *subject* and an *application*, so we'll need
to create those too.

But first, we need to install some preliminary resources into our REPL.
////

=== Data consistency

Actions that modify the database are run in a transaction function. This ensures
that the authorization check is made at the latest possible point, just before
the database is potentially modified. This avoids any potential for
race-conditions, for example, if the authorization to perform an Action is
revoked just before the Action is called.

=== Audit logging

Whenever an Action is called, the `do-action` transaction function is executed
which results in a *transaction metadata record* being created in the
database.

This makes it possible to find out when an Action was called, by whom, which
entities were affected and, potentially, other details such as the 'business
justification'.

If the Action is denied, or if errors occur when the Action is executed, details
will be recorded in the transaction metadata.

This allows us later to answer questions as to whether an Action was allowed or
denied, with an explanation. We will also be able to answer questions regarding
the who, when, why and how for each resource in the database.

A copy of the transaction metadata record is returned as a result of the
`do-action` function, as shown in <<transaction-metadata-record-example>>.

[[transaction-metadata-record-example]]
.A *transaction metadata record*
====

[source,clojure]
----
{:xt/id "urn:site:action-log:134"
 :xtdb.api/tx-id 134
 :juxt.pass.alpha/subject "urn:site:subjects:repl"
 :juxt.pass.alpha/action "https://site.test/actions/create-action"
 :juxt.pass.alpha/purpose nil
 :juxt.pass.alpha/puts ["https://site.test/actions/grant-permission"]
 :juxt.pass.alpha/deletes []}
----
====

== Document structure of an Action

<<action-doc-structure>> lists the attributes found in Action documents.

.Document structure of an Action
[[action-doc-structure]]
[%header,cols="2l,3d,1"]
|===
|Attribute|Value|Required?
|:juxt.site.alpha/type
l|"Action"
s|Required

|:juxt.pass.alpha/rules
|A collection of Datalog rules that determine whether the action is allowed.
s|Required

|:juxt.pass.alpha.malli/args-schema
|A Malli tuple schema that the action's arguments must conform to.
|Optional

|:juxt.pass.alpha/process
|A vector of processing steps which are executed when the action is called.
|Optional

|:juxt.pass.alpha/scope
|A _String_ representing the OAuth 2.0 scope containing the action.
|Optional
|===

.Mixing Site attributes with your application's attributes
****
All documents in the database can contain any additional attributes you need.

The `juxt.site`, `juxt.pass`, `juxt.http`, `xtdb.api` and `xt` namespaces are
reserved to avoid the potential for attribute clashes.

This flexibility to compose documents from different attributes is one of the
strengths of using a property-graph database such as XTDB under the hood.

See this talk segment by Stuart Halloway to explain the rationale for using namespaces in attribute keywords:
https://youtu.be/Qx0-pViyIDU?t=1464
****

== Installing a `create-action` Action

We must install an Action which allows us to create other Actions.

NOTE: This is the one Action that has to be put directly into the database because we
don't have a way of creating actions yet!

.Installing a `create-action` Action
[[example-create-action]]
====
[source,clojure]
----
include::../../dev/demo.clj[tag=install-create-action!,indent=0]
----
====
<1> The Action takes a single argument which must be a map containing (at least) an `:xt/id` value prefixed with `https://site.test/actions/` and a `:juxt.site.alpha/type` with the constant `"Action"`.
<2> The arguments will be updated such that the first (0th) argument is updated such that it contains the correct value for the `:juxt.site.alpha/type` attribute.
<3> The arguments will then be validated,
<4> then the arguments will be put as documents into the database.
<5> This is a Datalog rule which says that the Action will only be allowed if there exists a permission allowing the user to call the Action. The terms `permission` and `subject` will be covered in <<ch-subjects>>.

TIP: Copy and paste the code in <<example-create-action>> into the REPL and evaluate it (with btn:[Enter]).

=== Installing the `do-action` function

We must first install the transaction function into the database, so that we can
call actions we create.

[source,clojure]
.Install the do-action transaction function
----
include::../../dev/demo.clj[tag=install-do-action-fn!,indent=0]
----
