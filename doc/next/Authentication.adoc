= Authentication
:toc: left

== Introduction

To authorize a private resource we will need to establish the identity of the
person (or machine) that it attempting to access it.

Currently, Site does not provide its own authentication service but relies on a
third-party service known as an *OpenID Provider* that is capable of
authenticating an end-user and providing claims about them.

If Site trusts the OpenID Provider, and the OpenID Provider trusts the claims
made by the user, then Site can trust those user claims too.

When communicating with an OpenID Provider, Site assumes the role of an
https://www.rfc-editor.org/rfc/rfc6749#section-1.1[_OAuth 2.0 Client_], also known
as a *Relying Party*.

When an unidentified user accesses Site, Site can request an *ID Token*, which
contains the user's claims, from the OpenID Provider. These claims are trusted
by the OpenID Provider, which signs them with a cryptographic signature that
Site can verify.

TIP: Terminology for OpenID Connect can be found at
https://openid.net/specs/openid-connect-core-1_0.html#Terminology

Typically, the process of integrating an OpenID Provider comprises two steps.

The first step is to register an account with the OpenID Provider and let Site
fetch the OpenID Provider's configuration. This is described in
<<registering-the-openid-provider>>.

The second step is to create an OAuth 2.0 Client application which is what Site
will use to acquire an ID Token containing information (claims) about the
end-user we want to authenticate. This step is described in
<<creating-the-client-application>>.

It's possible to register mutliple OpenID Providers with Site, and there are
situations where there might be a need for more than one OAuth 2.0 Client
application to exist for a given OpenID Provider.

== Selecting an OpenID Provider

How the OpenID Provider establishes trust in the user's claims is up to the
OpenID Provider. It's important which choose a reputable provider that you
trust.

When it comes to choosing an OpenID Provider there are many options
available. Site is compatible with any of the many OpenID Providers that
implements the https://openid.net/specs/openid-connect-discovery-1_0.html[OpenID
Connect Discovery] protocol.

Examples include:

* https://auth0.com/[Auth0]
* https://aws.amazon.com/cognito/[AWS Cognito]
* https://developers.facebook.com/docs/facebook-login/limited-login/token/[Facebook]
* https://developers.google.com/identity/protocols/oauth2/openid-connect[Google]
* https://www.keycloak.org/[Keycloak]
* https://www.ory.sh/kratos[Ory Kratos]

[[registering-the-openid-provider]]
== Registering the OpenID Provider

The examples in this section explain how to configure a particular OpenID
Provider (Auth0) but the process is similar for other providers.

Site needs to be configured which each OpenID Provider via the
`install-openid-provider!` function, as demonstrated in
<<installing-an-openid-provider>>.

Site will then download and store the OpenID Provider's configuration which will
allow it to interact with the OpenID Provider, exchange information and verify the
signatures when the OpenID Provider returns cryptographically signed data.

[[installing-an-openid-provider]]
.Adding Auth0 as an OpenID Provider
====
We first created an account with Auth0 and chose the name `juxt` in the EU
region. Auth0 created the `juxt.eu.auth0.com` domain for us, representing the
Issuer.

|===
|Issuer Identifier|+https://juxt.eu.auth0.com+
|===

Then we registered Auth0 as an OpenID Provider in Site, with the *Issuer
Identifier* as a parameter:

[source,clojure]
----
(install-openid-provider! "https://juxt.eu.auth0.com")
----

CAUTION: If you've decided to use Auth0 too, you'll have to decide on a tenant
name and your Issuer Identifier will be different from ours. Make sure to
remember this when following the examples in this section.

====

[[creating-the-client-application]]
== Creating the OAuth 2.0 Client Application

OpenID is built open OAuth 2.0, so we must create an OAuth 2.0 Client
application which can represent Site in the OAuth 2.0 protocol.

The instructions for registering an OAuth 2.0 Client application with an OpenID
Provider are usually quite similar but you should follow the instructions
provided by your chosen OpenID Provider.

To communicate with the OpenID Provider, Site must provide a number of web
resources (endpoints). Once the OAuth 2.0 Client id and secret are known, these
can be created with the `install-openid-resources!` function.

The `install-openid-resources!` function requires the following arguments:

[cols="2,8"]
|===
|name|A unique name identifying the *OpenID Provider* and application registered in Site. This is encoded into the application's URIs so it's possible to have many such combinations.
|issuer-id|The *Issuer Identifier*, this is a URL, always starting with `https://`.
|client-id|The OAuth 2.0 *Client ID*
|client-secret|The OAuth 2.0 *Client Secret*
|===

If called successfully, the function will return the URIs of the various Site
resources created. These can be provided as OAuth 2.0 Client settings in the
OpenID Provider, and some of these will be required.

As a complete example, <<creating-a-client-application>> explains how we created
our client application in Auth0.

.Creating the OAuth 2.0 Client application in Auth0
[[creating-a-client-application]]
====
In Auth0 we located and selected the `Applications` menu item.

image::Auth0-Applications-Menuitem.png[width=20%]

This brought us to a screen listing applications, and we clicked on the button
`Create Application`.

image::Auth0-Create-Application-Button.png[width=20%]

This popped up a dialog, we chose a name of `site-test` and an application type
of `Regular Web Applications`.

image::Auth0-Create-Application.png[width=75%]

After the application was created, we accessed `Settings` from the application's menu bar.

image::Auth0-Application-Settings.png[]

We copied the `Client ID` and the `Client Secret`:

|===
|Client ID|d8X0TfEIcTl5oaltA4oy9ToEPdn5nFUK
|Client Secret|zb86gDUf_rEnwENYJBeih-cAzICjjPvvumThTw6qIqCVvtP83vYFtjuHni_m2ndt
|===

We returned to the REPL to install the web resources required to be provided by
the *Relying Party* (Site) by the *OpenID Provider* (Auth0), giving the
following values:

|===
|:name|auth0-site-test
|:issuer-id|+https://juxt.eu.auth0.com+
|:client-id|d8X0TfEIcTl5oaltA4oy9ToEPdn5nFUK
|:client-secret|zb86gDUf_rEnwENYJBeih-cAzICjjPvvumThTw6qIqCVvtP83vYFtjuHni_m2ndt
|===

We created the required web resources for the application by calling the
`install-openid-resources!` function.

[source,clojure]
----
(install-openid-resources!
:name "auth0-site-test"
:issuer-id "https://juxt.eu.auth0.com"
:client-id "d8X0TfEIcTl5oaltA4oy9ToEPdn5nFUK"
:client-secret "zb86gDUf_rEnwENYJBeih-cAzICjjPvvumThTw6qIqCVvtP83vYFtjuHni_m2ndt")
=>
{:login-uri "https://site.test/_site/openid/auth0-site-test/login",
 :callback-uri "https://site.test/_site/openid/auth0-site-test/callback"}
----

Calling the `install-openid-resources!` function returned a map containing the
application's URIs, which we made a note of.

|===
|Application Login URI|+https://site.test/_site/openid/auth0-site-test/login+
|Allowed Callback URLs|+https://site.test/_site/openid/auth0-site-test/callback+
|===

Then we returned to the Auth0 settings and scrolled down to the `Application URIs` section.

We entered in the application URIs as shown below:

image::Auth0-Application-URIs.png[]

====

== Redirecting a 401 response to the login resource

Remember the `401 Unauthorized` response we got back in
<<publishing-private-resources>>? Now we can at least authenticate the end-user.

If the user is using a browser, it's a better user experience if we redirect the
user from an unauthorized resource to the login resource, and then return them
to the original resource once they've been authenticated.

[source,clojure]
----
include::../../dev/demo.clj[tag=put-unauthorized-error-representation-for-html-2!,indent=0]
----


We're now ready to test.

----
curl -Li https://site.test/_site/openid/auth0-site-test/login
----

== Understanding the authentication flow

Site must acquire an ID_TOKEN in order to identify a subject.

The way it does this is by communicate with an OpenID Provider.

In the language of OAuth 2.0, Site takes on the role of a Client and the OpenID Provider
takes on the role of the Authorization Server.

Once Site has established confidence in the subject's claims, it can then
proceed to authorize access to its resources.

.How Site gets an ID_TOKEN
[plantuml,authentication-flow,png]
....
skinparam monochrome true
autonumber

actor Alice as user
participant browser

box Site
participant Client as site
database XT
end box

box "OpenID Provider"
participant "/authorize" as auth
participant "/login" as login
participant "/token" as token
end box

browser -> site: GET /login
site <- XT: Look up config of\nOpenID Provider
site -> XT: Create session cookie,\nwith state value
site -> browser: Set session cookie,\nredirect to /authorize
browser -> auth: GET /authorize, no session cookie
note over site: We are asking Alice to authorize Site's access to her details
note over auth: Who is this?
auth -> browser: Redirect to /login
browser -> login: GET /login
login -> browser: login page HTML
user -> browser: Enter password
browser -> login: POST
note over login: OK, it's Alice
login -> browser: Set session cookie, redirect to /authorize
browser -> auth: GET /authorize, this time with cookie
auth -> browser: Do you want to authorize Site?
user -> browser: Yes please!
browser -> auth: Yes
auth -> browser: Redirect to Site with this code
browser -> site: Here is the code and state
site <- XT: Check state value
site -> token: POST code
token -> site: ID_TOKEN containing\nAlice's details
site -> XT: Add ID_TOKEN to session
site -> browser: Upgrade session cookie

....
