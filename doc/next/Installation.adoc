= Installation
:toc: left

== Introduction

This is the long-winded installation guide to explain how to bootstrap a Site
instance.

This is partly for pedagogical purposes. It is a good idea to learn in depth how
Site's builds up its secure foundation. But if you are in a hurry, there are (or will be)
quicker 'install packs' and Docker images that provide shortcuts to setting up a
Site instance.

=== Requirements

Before you start, you'll need to have the following installed:

* Java 17+ (Site uses new Java APIs such as `java.util.HexFormat`)
* https://clojure.org/guides/getting_started[Clojure]
* https://github.com/babashka/babashka[Babashka]

=== Before you start

* All these instructions are for Arch Linux, please amend accordingly for your own
platform, if different.

* Run each command under your user account (i.e. not as root).

* For documentation purposes, we'll assume your Site server will be set up to run
on the host `site.test`. If you choose another hostname, or are setting up for
production, please amend these instructions accordingly.

== Preparation

=== Decide on a fully qualified hostname

Site is a web server and is designed to be accessed over the network. Since Site
resources are identified by URIs, you should decide on a hostname in a domain
that you control.

For the purposes of learning, development and local testing, it is a good idea
to use a test hostname, such as `site.test`. These instructions are written
assuming that you've chosen `site.test` as your hostname. If you're using your
own hostname in a domain you control, amend these instructions accordingly.

=== Configure your local DNS or /etc/hosts

To access Site locally for bootstrapping we need to ensure requests to
`site.test` are directed to the local service.

Edit /etc/hosts to direct requests for `site.test` to 127.0.0.1.

----
# Static table lookup for hostnames.
# See hosts(5) for details.
127.0.0.1	localhost site.test
----

=== mkcert

// TODO: Explain why we are doing this

Install mkcert

----
sudo pacman -Sy mkcert
----

----
mkcert -install
----

----
Created a new local CA ðŸ’¥
The local CA is now installed in the system trust store! âš¡ï¸
The local CA is now installed in the Firefox and/or Chrome/Chromium trust store (requires browser restart)! ðŸ¦Š
----

=== Install nginx

----
sudo pacman -Sy nginx-mainline
----

=== Create private key and cert

Create a new cert for the local development server, and move these into your
nginx config directory.

----
mkcert site.test
sudo mv site.test-key.pem site.test.pem /etc/nginx
----

=== Configure nginx

Configure nginx. Use `etc/dev/nginx.conf` as a guide to what to configure. You'll need to reference your private key and cert via the `ssl_certificate` and `ssl_certificate_key` parameters.

----
ssl_certificate      site.test.pem;
ssl_certificate_key  site.test-key.pem;
----

You'll need to increase the size of request bodies you can send through nginx,
the default is too restrictive.

----
client_max_body_size 16M;
----

You'll also need to configure the details of your the origin server (Site).

----
http {
  ...
  client_max_body_size 16M;
  ...
  server {
    ...
    ssl_certificate site.test.pem;
    ssl_certificate_key site.test-key.pem;
    ...
    location / {
      proxy_pass http://localhost:2021;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-Proto $scheme;
  }
}
----

Test your final configuration before you start nginx and fix any errors.

----
sudo nginx -t
----

=== Start nginx

Start nginx

----
sudo systemctl enable nginx
sudo systemctl start nginx
----

== Install Site

=== Clone this repo

----
$ git clone https://github.com/juxt/site
----

== Configure the Site service

=== Install the configuration file

There's a sample configuration in `etc` you should copy to `$HOME/.config/site/config.edn`.

----
$ mkdir -p $HOME/.config/site
$ cp site/etc/config.edn $HOME/.config/site/config.edn
----

IMPORTANT: If you're aren't using `site.test` as a hostname, edit the
configuration to replace `https://site.test` with the URI that corresponds to
the hostname you have chosen,

== Start the Site server

Start the Site server:

----
$ site/bin/site-server
----

NOTE: Alternatively, if you're familiar with Clojure development, you can start
the server via the `deps.edn` file and simply 'jack-in' with your editor or IDE
as normal.

////

(should retain this somewhere else)

=== Start multiple instances of the server

If you require multiple Site servers to coexist on the same machine, you can start site passing a different configuration file as follows:

----
$ SITE_CONFIG=/absolute/path/custom-site-config.edn site/bin/site-server
----

In this case please be sure to change the configuration so ports are different and XTDB files are stored in a separate folder than the ones specified in the example configuration file. You'll also need to specify Site host:port when using site commands, for example:

----
$ SITE_BASE_URI=http://localhost:5509 site/bin/site get-token -u admin
----
////

== Connect to Site's REPL

If you've run Site via your development environment and 'jacked-in' you'll
already have a REPL. Proceed to the next step.

If you're running Site with `site/bin/site-server`, you'll need to connect a
terminal to Site to access the REPL. You can do this via port `50505`, which is a
socket REPL that Site starts by default.

How you connect to this port is up to you. One way is via `ncat`, but you can replace `ncat` with `telnet`, or `netcat`, depending on what's available for your system.

[NOTE]
--
Arch users can install `ncat` by installing the `nmap` package:

----
$ sudo pacman -Sy nmap
----
--

----
$ ncat localhost 50505
----

[TIP]
--
Prefix the command with `rlwrap` if you have it installed.

----
$ rlwrap ncat localhost 50505
----
--

=== Introducing Site's REPL

----
Site by JUXT. Copyright (c) 2021, JUXT LTD.
Type :repl/quit to exit

site>
----

[TIP]
--
There are a few useful Site REPL commands you should be familiar with:

(ls):: List all resources
(ls <pat>):: List all resources whose URIs match the pattern
(evict! <uri>+):: Kill resource(s) across time
(apply evict! (ls)):: Start over. (Delete everything in the database!)
--

== Setup actions

////
(old text)

A Site instance is a collection of documents, stored in XTDB.

Like XTDB, Site is schemaless and requires that you define your own
documents. However, by included document attributes known to Site (usually in
the `juxt.site.alpha` namespace) Site is able to interpret the documents as web
or API resources, and serve them over HTTP.

We need to set up sufficient resources in the REPL so that we no longer need to
access Site via the REPL.

Secure remote access to Site resources requires an *access token*.

In this section we use the REPL to build up the minimal resources required to
acquire an access token which can let us continue setting up the server
remotely, without requiring further REPL access.

An access token is granted for a *subject* and an *application*, so we'll need
to create those too.

But first, we need to install some preliminary resources into our REPL.
////

Site adds the concept of *actions* to XTDB.

Actions make up the layer which mediates, authorizes and records read and write
access to the database.

* Actions are restricted to authorized users and applications.
* Actions run in transaction functions to ensure atomicity and consistency.
* Actions can provide involve input validation.
* Actions leave an audit trail and may trigger alerts.
* Actions can be grouped into OAuth2 scopes.
* Actions are used to build higher-level services, such as OpenAPI and GraphQL operations.

=== Install the `do-action` function

Executing actions in an XTDB transaction function guarantees consistency,
eliminating potential race-conditions. For example, it's important that any
revocation of a permission is applied if it is submitted before a request that
requires the permission.

The transaction function also records every action call in an *audit-log*,
detailing when the action was called, by whom, which entities were affected and,
potentially, other details such as the 'business justification'.

We must first install the transaction function into the database, so that we can
call actions we create.

[source,clojure]
.Install the do-action transaction function
----
(install-do-action-fn!)
----

=== Create a subject representing the REPL user

Actions are performed by **subject**s.

A subject represents an authenticated person, which will include personal data
as well as details about their login session (e.g. the device they are using,
whether their email address has been verified, whether their login required use
of a second factor, etc.).

To call actions from the REPL, we'll install a subject that can only be used
from the REPL. The `(me)` function returns a special built-in identifier for the
REPL subject.

[source,clojure]
.Add the REPL subject
----
(put! {:xt/id (me)})
----

NOTE: In future we might allow different users using the same REPL to identify
themselves. Of course, REPL users have no restrictions to what they can do, so
this is just for audit purposes among trusted users. Access to the REPL must be
restricted to a very limited set of authorized users.

=== Define the create-action action

We install the `create-action` action. This is the one action that has to be put
directly into the database because we don't have a way of creating actions yet!

[source,clojure]
.Install the create-action action
----
(install-create-action!)
----

[source,clojure]
.Permit the create-action action
----
(permit-create-action!)
----

=== Define the grant-permission action

Now that we have our `create-action` function installed we can use it to create
an action that will grant permissions.

----
(install-grant-permission-action!)
----

Note that this function will return a copy of the *transaction metadata record*
for the transaction that created the grant-permission action.

.Transaction Metadata Records
****

Whenever an action is called, the `do-action` transaction function is executed
which results in a *transaction metadata record* being created in the
database. If the action is denied, or if errors occur when the action is
executed, details will be recorded in the transaction metadata.

This allows us later to answer questions as to whether an action was allowed or
denied, with an explanation. We will also be able to answer questions regarding
the who, when, why and how for each document in the database.

.A *transaction metadata record*
====
A copy of the transaction metadata record is returned as a result of the `do-action` function.

[source,clojure]
----
{:xt/id "urn:site:action-log:134"
 :xtdb.api/tx-id 134
 :juxt.pass.alpha/subject "urn:site:subjects:repl"
 :juxt.pass.alpha/action "https://site.test/actions/create-action"
 :juxt.pass.alpha/purpose nil
 :juxt.pass.alpha/puts ["https://site.test/actions/grant-permission"]
 :juxt.pass.alpha/deletes []}
----
====
****

=== Permit REPL access to the grant permission action

We need to permit our REPL user to call this grant-permission action, and this permission too
needs to be put directly into the database since we don't yet have a way of
granting permissions!

.Granting the REPL user the permission to grant permssions.
----
(permit-grant-permission-action!)
----

== Add a trusted identity provider

Site does not store user credentials but requires that you provide one or more trusted identity providers that are compatible with OpenID Connect Discovery. Examples include https://www.keycloak.org/[Keycloak], https://auth0.com/[Auth0], Okta, Google, https://aws.amazon.com/cognito/[AWS Cognito] and many more.

.Adding Auth0 as an OpenID Connect provider
====
Create an account with Auth0 and note the Auth0 tenant (domain).

[source,clojure]
----
(add-openid-provider! "https://juxt.eu.auth0.com")
----

Create an app client and take a note of the client-id and client-secret.

[source,clojure]
----
(add-openid-login!
:name "auth0"
:provider "https://juxt.eu.auth0.com/.well-known/openid-configuration"
:client-id "<client-id>"
:client-secret "<client-secret>")
----
====

== Create users

=== Create a user

To remotely access the system, we'll first have to build a user.

For this example, we'll model a user as a combination of:

- A *person*,

- A person's *identity*, as issued from a trusted entity such as an OAuth2
  Authorization Server, Identity Provider or equivalent,

- A *subject* which represents the person's current *session*, including details
  of how they logged in.

NOTE: We don't have to model a user this way, and for some applications this
might be overly simplistic. Site allows you to model your own users as you see
fit, as long as there is something to represent a *subject*.

For the purposes of this example, we'll create a person entity to represent the
person.

We'll use the name `Alice` but feel free to replace this with your own personal
details.

==== Create an action to create a person

First, we'll need to create an action which will create our person entity.

.Creating the create-person action
====

[source,clojure]
.Install the create-person action
----
(create-action!
{:xt/id "https://site.test/actions/create-person" <1>
 :juxt.pass.alpha/scope "write:admin" <2>

 :juxt.pass.alpha.malli/args-schema <3>
 [:tuple
   [:map
     [:xt/id [:re "https://site.test/people/\\p{Alpha}{2,}"]]
     [:example/type [:= "Person"]]
     [:example/name [:string]]]]

 :juxt.pass.alpha/process <4>
 [
  [:juxt.pass.alpha.process/update-in [0] 'merge {:example/type "Person"}]
  [:juxt.pass.alpha.malli/validate]
  [:xtdb.api/put]]

 ::pass/rules <5>
 '[
   [(allowed? permission subject action resource)
    [permission ::pass/subject subject]]]}
)
----
<1> You can choose any id here but it's a good idea to keep to a convention
<2> Actions are grouped into OAuth2 scopes
<3> Arguments must conform to this schema
<4> The processing pipeline which transforms arguments into XT transaction operations
<5> An action declares the rules as to who is authorized to call it
====

==== Permit the REPL to call the create-person action

.Adding the permission for the REPL to create a person
====

[source,clojure]
----
(grant-permission!
{:xt/id "https://site.test/permissions/repl/create-person"
 ::pass/subject (me)
 ::pass/action #{"https://site.test/actions/create-person"}
 ::pass/purpose nil
 }
)
----
====

==== Create 'Alice' with the create-person action

.Creating 'Alice'
====

[source,clojure]
----
(do-action "https://site.test/actions/create-person"
  {:xt/id "https://site.test/people/alice"
  :example/name "Alice"})
----
====

=== Create an identity to identify Alice

Now we need to register an *identity* for Alice so that we can trust her.

////
.Keep this for when we need to create a subject for Alice
****
We do this because we may want our rules to take into account other aspects of
Alice's session rather than just the fact that it belongs to Alice. For example,
we may want some actions to be denied if Alice is logging in from an insecure
location or from a different country.
****
////

==== Create an action to create a identity

.Creating an action for creating the identity
====
[source,clojure]
----
(create-action!
 {:xt/id "https://site.test/actions/create-identity"
  :juxt.pass.alpha/scope "write:admin"

  :juxt.pass.alpha.malli/args-schema
  [:tuple
   [:map
    [:juxt.site.alpha/type [:= "Identity"]]
    [:example/person [:re "https://site.test/people/\\p{Alpha}{2,}"]]]]

  :juxt.pass.alpha/process
  [
   [:juxt.pass.alpha.process/update-in [0] 'merge {:juxt.site.alpha/type "Identity"}]
   [:juxt.pass.alpha.malli/validate]
   [:xtdb.api/put]]

  :juxt.pass.alpha/rules
  '[
    [(allowed? permission subject action resource)
     [permission :juxt.pass.alpha/subject subject]]]})
----
====

==== Permit the REPL to call the create-identity action

.Adding a permission on the create-identity action
====

[source,clojure]
----
(grant-permission!
 {:xt/id "https://site.test/permissions/repl/create-identity"
  :juxt.pass.alpha/subject "urn:site:subjects:repl"
  :juxt.pass.alpha/action #{"https://site.test/actions/create-identity"}
  :juxt.pass.alpha/purpose nil})
----
====

==== Call the create-identity action

.Calling the create-identity action
====
[source,clojure]
----
(do-action
 "https://site.test/actions/create-identity"
 {:xt/id "https://site.test/identities/alice"
  :example/person "https://site.test/people/alice"
  :juxt.pass.jwt/iss "https://juxt.eu.auth0.com/"
  :juxt.pass.jwt/sub "github|123456"})
----
====

////
might not be necessary

=== Register an application

TODO

==== Create an action to register an application

TODO

==== Permit the REPL to call the register-application action

TODO

==== Call the register-application action

TODO

////

=== Create an access token

TODO

== Run the site tool

The site tool is a command-line utility that allows you to remotely administer Site.

****
If you're on MacOS, you will need to install the GNU version of `readlink`. You can do so with brew:
```
brew install coreutils
ln -s /usr/local/bin/readlink /usr/local/bin/readlink
```
****

We must first get a token that we can use for API access. This process authenticates to the site server using your password.

.Here, replace `admin` with your username (or let it default to your OS username)
----
$ site/bin/site get-token -u admin
----

Now we can use the site tool for remote administration. Try the following:

----
$ site/bin/site list-users
----

== Configure an authorization server

Site is a Resource Server, responsible for serving resources such as:

- Static web pages and media
- API responses
- GraphQL responses

As a Resource Server, Site is responsible for protecting the resources owned by
users from unauthorized access.

Rather than sending credentials, clients (applications) obtain and use
access-tokens to access Site's resources.

Site hosts the authorization server by which clients can obtain access tokens.

----
(install-authorization-server! {:name "Authorization Server"})
(install-token-endpoint! {:xt/id "https://site.test/token"})
(register-application! {:name "My Application"})
----

== Post installation steps

=== Configure the expiry time for tokens

By default, tokens last for an hour. That can sometimes mean they expire during
work sessions. You can set the expiry time of new tokens via the REPL.

----
(put! (assoc (e "http://localhost:2021/_site/token")  ::pass/expires-in (* 24 3600)))
----
