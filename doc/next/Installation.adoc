= Installation
:toc: left

== Introduction

This is the long-winded installation guide to explain how to bootstrap a Site
instance.

This is partly for pedagogical purposes. It is a good idea to learn in depth how
Site's builds up its secure foundation. But if you are in a hurry, there are (or will be)
quicker 'install packs' and Docker images that provide shortcuts to setting up a
Site instance.

=== Requirements

Before you start, you'll need to have the following installed:

* Java 17+ (Site uses new Java APIs such as `java.util.HexFormat`)
* https://clojure.org/guides/getting_started[Clojure]
* https://github.com/babashka/babashka[Babashka]

=== Before you start

* All these instructions are for Arch Linux, please amend accordingly for your own
platform, if different.

* Run each command under your user account (i.e. not as root).

* For documentation purposes, we'll assume your Site server will be set up to run
on the host `site.test`. If you choose another hostname, or are setting up for
production, please amend these instructions accordingly.

== Preparation

=== Decide on a fully qualified hostname

Site is a web server and is designed to be accessed over the network. Since Site
resources are identified by URIs, you should decide on a hostname in a domain
that you control.

For the purposes of learning, development and local testing, it is a good idea
to use a test hostname, such as `site.test`. These instructions are written
assuming that you've chosen `site.test` as your hostname. If you're using your
own hostname in a domain you control, amend these instructions accordingly.

=== Configure your local DNS or /etc/hosts

To access Site locally for bootstrapping we need to ensure requests to
`site.test` are directed to the local service.

Edit /etc/hosts to direct requests for `site.test` to 127.0.0.1.

----
# Static table lookup for hostnames.
# See hosts(5) for details.
127.0.0.1	localhost site.test
----

=== mkcert

// TODO: Explain why we are doing this

Install mkcert

----
sudo pacman -Sy mkcert
----

----
mkcert -install
----

----
Created a new local CA 💥
The local CA is now installed in the system trust store! ⚡️
The local CA is now installed in the Firefox and/or Chrome/Chromium trust store (requires browser restart)! 🦊
----

=== Install nginx

----
sudo pacman -Sy nginx-mainline
----

=== Create private key and cert

Create a new cert for the local development server, and move these into your
nginx config directory.

----
mkcert site.test
sudo mv site.test-key.pem site.test.pem /etc/nginx
----

=== Configure nginx

Configure nginx. Use `etc/dev/nginx.conf` as a guide to what to configure. You'll need to reference your private key and cert via the `ssl_certificate` and `ssl_certificate_key` parameters.

----
ssl_certificate      site.test.pem;
ssl_certificate_key  site.test-key.pem;
----

You'll need to increase the size of request bodies you can send through nginx,
the default is too restrictive.

----
client_max_body_size 16M;
----

You'll also need to configure the details of your the origin server (Site).

----
http {
  ...
  client_max_body_size 16M;
  ...
  server {
    ...
    ssl_certificate site.test.pem;
    ssl_certificate_key site.test-key.pem;
    ...
    location / {
      proxy_pass http://localhost:2021;
      proxy_set_header Host $host;
      proxy_set_header X-Real-IP $remote_addr;
      proxy_set_header X-Forwarded-Proto $scheme;
  }
}
----

Test your final configuration before you start nginx and fix any errors.

----
sudo nginx -t
----

=== Start nginx

Start nginx

----
sudo systemctl enable nginx
sudo systemctl start nginx
----

== Install Site

=== Clone this repo

----
$ git clone https://github.com/juxt/site
----

== Configure the Site service

=== Install the configuration file

There's a sample configuration in `etc` you should copy to `$HOME/.config/site/config.edn`.

----
$ mkdir -p $HOME/.config/site
$ cp site/etc/config.edn $HOME/.config/site/config.edn
----

IMPORTANT: If you're aren't using `site.test` as a hostname, edit the
configuration to replace `https://site.test` with the URI that corresponds to
the hostname you have chosen,

== Start the Site server

Start the Site server:

----
$ site/bin/site-server
----

NOTE: Alternatively, if you're familiar with Clojure development, you can start
the server via the `deps.edn` file and simply 'jack-in' with your editor or IDE
as normal.

////

(should retain this somewhere else)

=== Start multiple instances of the server

If you require multiple Site servers to coexist on the same machine, you can start site passing a different configuration file as follows:

----
$ SITE_CONFIG=/absolute/path/custom-site-config.edn site/bin/site-server
----

In this case please be sure to change the configuration so ports are different and XTDB files are stored in a separate folder than the ones specified in the example configuration file. You'll also need to specify Site host:port when using site commands, for example:

----
$ SITE_BASE_URI=http://localhost:5509 site/bin/site get-token -u admin
----
////

== Connect to Site's REPL

If you've run Site via your development environment and 'jacked-in' you'll
already have a REPL. Proceed to the next step.

If you're running Site with `site/bin/site-server`, you'll need to connect a
terminal to Site to access the REPL. You can do this via port `50505`, which is a
socket REPL that Site starts by default.

How you connect to this port is up to you. One way is via `ncat`, but you can replace `ncat` with `telnet`, or `netcat`, depending on what's available for your system.

[NOTE]
--
Arch users can install `ncat` by installing the `nmap` package:

----
$ sudo pacman -Sy nmap
----
--

----
$ ncat localhost 50505
----

[TIP]
--
Prefix the command with `rlwrap` if you have it installed.

----
$ rlwrap ncat localhost 50505
----
--

=== Introducing Site's REPL

----
Site by JUXT. Copyright (c) 2021, JUXT LTD.
Type :repl/quit to exit

site>
----

[TIP]
--
There are a few useful Site REPL commands you should be familiar with:

(ls):: List all resources
(ls <pat>):: List all resources whose URIs match the pattern
(evict! <uri>+):: Kill resource(s) across time
(apply evict! (ls)):: Start over. (Delete everything in the database!)
--

== Setup actions

////
(old text)

A Site instance is a collection of documents, stored in XTDB.

Like XTDB, Site is schemaless and requires that you define your own
documents. However, by included document attributes known to Site (usually in
the `juxt.site.alpha` namespace) Site is able to interpret the documents as web
or API resources, and serve them over HTTP.

We need to set up sufficient resources in the REPL so that we no longer need to
access Site via the REPL.

Secure remote access to Site resources requires an *access token*.

In this section we use the REPL to build up the minimal resources required to
acquire an access token which can let us continue setting up the server
remotely, without requiring further REPL access.

An access token is granted for a *subject* and an *application*, so we'll need
to create those too.

But first, we need to install some preliminary resources into our REPL.
////

Site adds the concept of *actions* to XTDB.

Actions make up the layer which mediates, authorizes and records read and write
access to the database.

* Actions are restricted to authorized users and applications.
* Actions run in transaction functions to ensure atomicity and consistency.
* Actions can provide involve input validation.
* Actions leave an audit trail and may trigger alerts.
* Actions can be grouped into OAuth2 scopes.
* Actions are used to build higher-level services, such as OpenAPI and GraphQL operations.

=== Install the `do-action` function

Executing actions in an XTDB transaction function guarantees consistency,
eliminating potential race-conditions. For example, it's important that any
revocation of a permission is applied if it is submitted before a request that
requires the permission.

The transaction function also records every action call in an *audit-log*,
detailing when the action was called, by whom, which entities were affected and,
potentially, other details such as the 'business justification'.

We must first install the transaction function into the database, so that we can
call actions we create.

[source,clojure]
.Install the do-action transaction function
----
(install-do-action-fn!)
----

=== Create a subject representing the REPL user

Actions are performed by **subject**s.

A subject represents an authenticated person, which will include personal data
as well as details about their login session (e.g. the device they are using,
whether their email address has been verified, whether their login required use
of a second factor, etc.).

To call actions from the REPL, we'll install a subject that can only be used
from the REPL. The `(me)` function returns a special built-in identifier for the
REPL subject.

[source,clojure]
.Add the REPL subject
----
(put! {:xt/id (me)})
----

NOTE: In future we might allow different users using the same REPL to identify
themselves. Of course, REPL users have no restrictions to what they can do, so
this is just for audit purposes among trusted users. Access to the REPL must be
restricted to a very limited set of authorized users.

=== Define the create-action action

We install the `create-action` action. This is the one action that has to be put
directly into the database because we don't have a way of creating actions yet!

[source,clojure]
.Install the create-action action
----
(install-create-action!)
----

[source,clojure]
.Permit the create-action action
----
(permit-create-action!)
----

=== Define the grant-permission action

Now that we have our `create-action` function installed we can use it to create
an action that will grant permissions.

----
(install-grant-permission-action!)
----

Note that this function will return a copy of the *transaction metadata record*
for the transaction that created the grant-permission action.

.Transaction Metadata Records
****

Whenever an action is called, the `do-action` transaction function is executed
which results in a *transaction metadata record* being created in the
database. If the action is denied, or if errors occur when the action is
executed, details will be recorded in the transaction metadata.

This allows us later to answer questions as to whether an action was allowed or
denied, with an explanation. We will also be able to answer questions regarding
the who, when, why and how for each document in the database.

.A *transaction metadata record*
====
A copy of the transaction metadata record is returned as a result of the `do-action` function.

[source,clojure]
----
{:xt/id "urn:site:action-log:134"
 :xtdb.api/tx-id 134
 :juxt.pass.alpha/subject "urn:site:subjects:repl"
 :juxt.pass.alpha/action "https://site.test/actions/create-action"
 :juxt.pass.alpha/purpose nil
 :juxt.pass.alpha/puts ["https://site.test/actions/grant-permission"]
 :juxt.pass.alpha/deletes []}
----
====
****

=== Permit REPL access to the grant permission action

We need to permit our REPL user to call this grant-permission action, and this permission too
needs to be put directly into the database since we don't yet have a way of
granting permissions!

.Granting the REPL user the permission to grant permssions.
----
(permit-grant-permission-action!)
----
